== Instruction ==
C code
Assembly code
Hex code
Reference Output
================

ADDIU Add immediate unsigned (no overflow) 

== ADDU Add unsigned (no overflow) ==

int main(void) {
    int a = 3 + 5;
}

ORI $4,$0,3
ORI $5,$0,5
ADDU $2,$4,$5
JR $0

34040003
34050005
00851021
00000008

register_v0 = 8

AND Bitwise and
ANDI Bitwise and immediate

==BEQ	Branch on equal==

ORI $4,$0,5
ORI $5,$0,5
BEQ $4,$5,3
NOP 
JR $0
NOP
ORI $2,$0,1
JR $0

34040005
34050005
10850003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==BGEZ Branch on greater than or equal to zero==

ORI $4,$0,3
BGEZ $4,3
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

34040003
04810003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==BGEZAL Branch on non-negative (>=0) and link==

ORI $4,$0,3
BGEZAL $4,4
NOP
ADDIU $2,$2,1
JR $0
NOP
ORI $2,$0,1
JR $31

34040003
04910004
00000000
24420001
00000008
00000000
34020001
03E00008

register_v0 = 2

==BGTZ Branch on greater than zero==

ORI $4,$0,3
BGTZ $4,3
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

34040003
1C800003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==BLEZ Branch on less than or equal to zero==

ORI $4,$0,-1
BLEZ $4,3
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

3404FFFF
18800003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==BLTZ Branch on less than zero==

ORI $4,$0,-1
BLTZ $4,3
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

3404FFFF
04800003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==BLTZAL	Branch on less than zero and link==

ORI $4,$0,-1
BLTZAL $4,4
NOP
ADDIU $2,$2,1
JR $0
NOP
ORI $2,$0,1
JR $31

3404FFFF
04900004
00000000
24420001
00000000
00000008
34020001
03E00008

register_v0 = 2

==BNE	Branch on not equal==

ORI $4,$0,3
ORI $5,$0,5
BNE $4,$5,3
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

34040003
34040005
14850003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

DIV	Divide
DIVU	Divide unsigned

==J	Jump==
J 4
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

08000004
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==JALR	Jump and link register==
ORI $5,$0,1C
LUI $5,BFC0
JALR $4,$5
NOP
ADDIU $2,$2,1
JR $0
NOP
ORI $2,$0,1
JR $4

3405001C
3C05BCF0
00A02009
00000000
24420001
00000008
00000000
34020001
00800008


register_v0 = 2

==JAL	Jump and link==
JAL 5
NOP
ADDIU $2,$2,1
JR $0
NOP
ORI $2,$0,1
JR $31

0C000005
00000000
24420001
00000008
00000000
34020001
03E00008

register_v0 = 2

==JR	Jump register==
ORI $5,$0,14
LUI $5,BFC0  
JR $5  
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

34050014
3C05BCF0
00A00008
00000000
00000008
34020001
00000008

register_v0 = 1

LB	Load byte
LBU	Load byte unsigned
LH	Load half-word
LHU	Load half-word unsigned
LUI	Load upper immediate
LW	Load word
LWL	Load word left
LWR	Load word right
MTHI	Move to HI
MTLO	Move to LO
MULT	Multiply
MULTU	Multiply unsigned
OR	Bitwise or
ORI	Bitwise or immediate
SB	Store byte
SH	Store half-word
SLL	Shift left logical
SLLV	Shift left logical variable
SLT	Set on less than (signed)
SLTI	Set on less than immediate (signed)
SLTIU	Set on less than immediate unsigned
SLTU	Set on less than unsigned
SRA	Shift right arithmetic
SRAV	Shift right arithmetic
SRL	Shift right logical
SRLV	Shift right logical variable
SUBU	Subtract unsigned
SW	Store word
XOR	Bitwise exclusive or
XORI	Bitwise exclusive or immediate
