== Instruction ==
C code
Assembly code
Hex code
Reference Output
================

ADDIU Add immediate unsigned (no overflow) 

== ADDU Add unsigned (no overflow) ==

int main(void) {
    int a = 3 + 5;
}

ORI $4,$0,3
ORI $5,$0,5
ADDU $2,$4,$5
JR $0

34040003
34050005
00851021
00000008

register_v0 = 8

==AND Bitwise and==

ORI $5,$0,0xCCCC
LUI $5,0xCCCC 
ORI $4,$0,0xAAAA
LUI $4,0xAAAA  
AND  $2,$4,$5
JR $0

3405cccc
3c05cccc
3404aaaa
3c04aaaa
00851024
00000008

register_v0 = 0x88888888

==ANDI Bitwise and immediate==

ORI $4,$0,0xAAAA
LUI $4,0xAAAA  
ANDI $2,$4,0xCCCC
JR $0

3404aaaa
3c04aaaa
3082cccc
00000008

register_v0 = 0x00008888

==BEQ	Branch on equal==

ORI $4,$0,5
ORI $5,$0,5
BEQ $4,$5,3
NOP 
JR $0
NOP
ORI $2,$0,1
JR $0

34040005
34050005
10850003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==BGEZ Branch on greater than or equal to zero==

ORI $4,$0,3
BGEZ $4,3
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

34040003
04810003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==BGEZAL Branch on non-negative (>=0) and link==

ORI $4,$0,3
BGEZAL $4,4
NOP
ADDIU $2,$2,1
JR $0
NOP
ORI $2,$0,1
JR $31

34040003
04910004
00000000
24420001
00000008
00000000
34020001
03E00008

register_v0 = 2

==BGTZ Branch on greater than zero==

ORI $4,$0,3
BGTZ $4,3
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

34040003
1C800003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==BLEZ Branch on less than or equal to zero==

LUI $4,0xFFFF
BLEZ $4,3
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

3C05FFFF
18800003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==BLTZ Branch on less than zero==

LUI $4,0xFFFF 
BLTZ $4,3
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

3C05FFFF
04800003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==BLTZAL	Branch on less than zero and link==

LUI $4,0xFFFF 
BLTZAL $4,4
NOP
ADDIU $2,$2,1
JR $0
NOP
ORI $2,$0,1
JR $31

3C05FFFF
04900004
00000000
24420001
00000008
00000000
34020001
03E00008

register_v0 = 2

==BNE	Branch on not equal==

ORI $4,$0,3
ORI $5,$0,5
BNE $4,$5,3
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

34040003
34040005
14850003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==DIV	Divide== //May need other testcases for -ve/+ve, -ve/-ve

ORI $4,$0,3
ORI $5,$0,9
DIV  $5,$4
MFHI $4
MFLO $5
ADDU $2,$4,$5
JR $0

34040003
34050009
00A4001A
00002010
00002812
00851021
00000008

register_v0 = 3

==DIVU	Divide unsigned== //May need other testcases for -ve/+ve, -ve/-ve

LUI $4,0x8000 
ORI $5,$0,2
DIVU  $4,$5
MFHI $4
MFLO $5
ADDU $2,$4,$5
JR $0

34048000
34050002
0085001B
00002010
00002812
00851021
00000008

register_v0 = 0x40000000

==J	Jump==

J 4
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

08000004
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==JALR	Jump and link register==

ORI $5,$0,0x001C
LUI $5,0xBFC0
JALR $4,$5
NOP
ADDIU $2,$2,1
JR $0
NOP
ORI $2,$0,1
JR $4

3405001C
3C05BCF0
00A02009
00000000
24420001
00000008
00000000
34020001
00800008

register_v0 = 2

==JAL	Jump and link==

JAL 5
NOP
ADDIU $2,$2,1
JR $0
NOP
ORI $2,$0,1
JR $31

0C000005
00000000
24420001
00000008
00000000
34020001
03E00008

register_v0 = 2

==JR	Jump register==

ORI $5,$0,0x0014
LUI $5,0xBFC0  
JR $5  
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

34050014
3C05BCF0
00A00008
00000000
00000008
34020001
00000008

register_v0 = 1

==LB	Load byte==

ORI $4,$0,0x1003
LB  $2,3($4)
JR $0

-Instruction Hex

34041003
80820003
00000008

-Memory Hex

00000000
008A0000
00000000
00000000

register_v0 = 0xFFFFFF8A

==LBU	Load byte unsigned==

ORI $4,$0,0x1003
LBU  $2,3($4)
JR $0

-Instruction Hex

34041003
90820003
00000008

-Memory Hex

00000000
008A0000
00000000
00000000

register_v0 = 0x0000008A

==LH	Load half-word==

ORI $4,$0,0x1003
LH  $2,4($4)
JR $0

-Instruction Hex

34041003
84820004
00000008

-Memory Hex

00000000
00008123
00000000
00000000

register_v0 = 0xFFFF8123

==LHU	Load half-word unsigned==

ORI $4,$0,0x1003
LHU $2,4($4)
JR $0

-Instruction Hex

34041003
94820004
00000008

-Memory Hex

00000000
00008123
00000000
00000000

register_v0 = 0x00008123

==LUI	Load upper immediate==

ORI $2,$0,0x5678
LUI $2,0x1234
JR $0

34045678
3C021234
00000008

register_v0 = 0x12345678

==LW	Load word==

ORI $4,$0,0x1002
LW  $2, 2($4)
JR $0

-Instruction Hex

34041002
8C820002
00000008

-Memory Hex

00000000
12345678
00000000
00000000

register_v0 = 0x12345678

==LWL	Load word left==

ORI $4,$0,0x1003
ORI $2,$0,0x5678
LWL  $2,3($4)
JR $0

-Instruction Hex

34041003
34025678
88820003
00000008

-Memory Hex

00000000
AAAA1234
00000000
00000000

register_v0 = 0x12345678

==LWR	Load word right==

ORI $4,$0,0x1003
LUI $2,0x1234
LWR $2,2($4)
JR $0

-Instruction Hex

34041003
3C021234
98820002
00000008

-Memory Hex

00000000
5678AAAA
00000000
00000000

register_v0 = 0x12345678

// DIVU Divide unsigned

// DIV Divide

//MFHI Move from Hi 

//MFLO Move from lo 

//MTHI	Move to HI

//MTLO	Move to LO

//MULT	Multiply**

//MULTU	Multiply unsigned**

//OR	Bitwise or

//ORI	Bitwise or immediate

//SB	Store byte

//SH	Store half-word**

//SLL	Shift left logical

//SLLV	Shift left logical variable 

//SLT	Set on less than (signed)

//SLTI	Set on less than immediate (signed)

//SLTIU	Set on less than immediate unsigned

//SLTU	Set on less than unsigned

//SRA	Shift right arithmetic

//SRAV	Shift right arithmetic

//SRL	Shift right logical

//SRLV	Shift right logical variable

//SUBU	Subtract unsigned

//SW	Store word

//XOR	Bitwise exclusive or

//XORI	Bitwise exclusive or immediate
