== Instruction ==
Assembly code
Hex code
Reference Output
================

==ADDIU Add immediate unsigned (no overflow)==

ORI $4,$0,0xA
ADDIU $2,$4,20
JR $0

3404000a
24820014
00000008

register_v0 = 30

== ADDU Add unsigned (no overflow) ==

ORI $4,$0,3
ORI $5,$0,5
ADDU $2,$4,$5
JR $0

34040003
34050005
00851021
00000008

register_v0 = 8

==AND Bitwise and==

LUI $5,0xCCCC 
ORI $5,$0,0xCCCC
LUI $4,0xAAAA 
ORI $4,$0,0xAAAA
 
AND  $2,$4,$5
JR $0

3c05cccc
3405cccc
3c04aaaa
3404aaaa
00851024
00000008

register_v0 = 0x88888888

==ANDI Bitwise and immediate==

LUI $4,0xAAAA 
ORI $4,$0,0xAAAA
ANDI $2,$4,0xCCCC
JR $0

3c04aaaa
3404aaaa
3082cccc
00000008

register_v0 = 0x00008888

==BEQ	Branch on equal==

ORI $4,$0,5
ORI $5,$0,5
BEQ $4,$5,3
NOP 
JR $0
NOP
ORI $2,$0,1
JR $0

34040005
34050005
10850003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==BGEZ Branch on greater than or equal to zero==

ORI $4,$0,3
BGEZ $4,3
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

34040003
04810003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==BGEZAL Branch on non-negative (>=0) and link==

ORI $4,$0,3
BGEZAL $4,4
NOP
ADDIU $2,$2,1
JR $0
NOP
ORI $2,$0,1
JR $31

34040003
04910004
00000000
24420001
00000008
00000000
34020001
03E00008

register_v0 = 2

==BGTZ Branch on greater than zero==

ORI $4,$0,3
BGTZ $4,3
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

34040003
1C800003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==BLEZ Branch on less than or equal to zero==

LUI $4,0xFFFF
BLEZ $4,3
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

3C05FFFF
18800003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==BLTZ Branch on less than zero==

LUI $4,0xFFFF 
BLTZ $4,3
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

3C05FFFF
04800003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==BLTZAL	Branch on less than zero and link==

LUI $4,0xFFFF 
BLTZAL $4,4
NOP
ADDIU $2,$2,1
JR $0
NOP
ORI $2,$0,1
JR $31

3C05FFFF
04900004
00000000
24420001
00000008
00000000
34020001
03E00008

register_v0 = 2

==BNE	Branch on not equal==

ORI $4,$0,3
ORI $5,$0,5
BNE $4,$5,3
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

34040003
34040005
14850003
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==DIV	Divide== //May need other testcases for -ve/+ve, -ve/-ve

ORI $4,$0,3
ORI $5,$0,9
DIV  $5,$4
MFHI $4
MFLO $5
ADDU $2,$4,$5
JR $0

34040003
34050009
00A4001A
00002010
00002812
00851021
00000008

register_v0 = 3

==DIVU	Divide unsigned== //May need other testcases for -ve/+ve, -ve/-ve

LUI $4,0x8000 
ORI $5,$0,2
DIVU  $4,$5
MFHI $4
MFLO $5
ADDU $2,$4,$5
JR $0

34048000
34050002
0085001B
00002010
00002812
00851021
00000008

register_v0 = 0x40000000

==J	Jump==

J 4
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

08000004
00000000
00000008
00000000
34020001
00000008

register_v0 = 1

==JALR	Jump and link register==

LUI $5,0xBFC0
ORI $5,$0,0x001C
JALR $4,$5
NOP
ADDIU $2,$2,1
JR $0
NOP
ORI $2,$0,1
JR $4

3C05BCF0
3405001C
00A02009
00000000
24420001
00000008
00000000
34020001
00800008

register_v0 = 2

==JAL	Jump and link==

JAL 5
NOP
ADDIU $2,$2,1
JR $0
NOP
ORI $2,$0,1
JR $31

0C000005
00000000
24420001
00000008
00000000
34020001
03E00008

register_v0 = 2

==JR	Jump register==

LUI $5,0xBFC0  
ORI $5,$5,0x0014
JR $5  
NOP
JR $0
NOP
ORI $2,$0,1
JR $0

3C05BFC0
34050014
00A00008
00000000
00000008
34020001
00000008

register_v0 = 1

==LB	Load byte==

ORI $4,$0,0x1003
LB  $2,3($4)
JR $0

-Instruction Hex

34041000
80820006
00000008

-Memory Hex

00000000
008A0000
00000000
00000000

register_v0 = 0xFFFFFF8A

==LBU	Load byte unsigned==

ORI $4,$0,0x1003
LBU  $2,3($4)
JR $0

-Instruction Hex

34041003
90820003
00000008

-Memory Hex

00000000
008A0000
00000000
00000000

register_v0 = 0x0000008A

==LH	Load half-word==

ORI $4,$0,0x1003
LH  $2,4($4)
JR $0

-Instruction Hex

34041003
84820004
00000008

-Memory Hex

00000000
00008123
00000000
00000000

register_v0 = 0xFFFF8123

==LHU	Load half-word unsigned==

ORI $4,$0,0x1003
LHU $2,4($4)
JR $0

-Instruction Hex

34041003
94820004
00000008

-Memory Hex

00000000
00008123
00000000
00000000

register_v0 = 0x00008123

==LUI	Load upper immediate==

LUI $2,0x1234
ORI $2,$2,0x5678
JR $0

3C021234
34425678
00000008

register_v0 = 0x12345678

==LW	Load word==

ORI $4,$0,0x1002
LW  $2, 2($4)
JR $0

-Instruction Hex

34041002
8C820002
00000008

-Memory Hex

00000000
12345678
00000000
00000000

register_v0 = 0x12345678

==LWL	Load word left==

ORI $4,$0,0x1001
ORI $2,$0,0x5678
LWL  $2,3($4)
JR $0

-Instruction Hex

34041001
34025678
88820003
00000008

-Memory Hex

00000000
AAAA1234
00000000
00000000

register_v0 = 0x12345678

==LWR	Load word right==

LUI $2,0x1234
ORI $4,$0,0x1002
LWR $2,2($4)
JR $0

-Instruction Hex

3C021234
34041002
98820002
00000008

-Memory Hex

00000000
5678AAAA
00000000
00000000

register_v0 = 0x12345678

==MTHI	Move to HI==

ori $4, $0, 5
mthi $4
mfhi $2
jr $0

34040005
00800011
00001010
00000008

register_v0 = 5

==MTLO	Move to LO==

ori $4, $0, 5
mtlo $4
mflo $2
jr $0

34040005
00800013
00001012
00000008

register_v0 = 5

==MULT	Multiply==

ori $4, $0, 4
ori $5, $0, 3
mult $4, $5
mflo $2
jr $0

34040004
34050003
00850018
00001012
00000008

register_v0 = 12

==MULTU	Multiply unsigned==

ori $4, $0, 4
ori $5, $0, 3
multu $4, $5
mflo $2
jr $0

34040004
34050003
00850019
00001012
00000008

register_v0 = 12

==OR	Bitwise or==

ori $4, $0, 5
ori $5, $0, 3
or $2, $4, $5
jr $0

34040005
34050003
00851025
00000008

register_v0 = 7

==ORI	Bitwise or immediate==

ori $2, $0, 3
ori $2, $0, 5
jr $0

34020003
00000008
34020005

register_v0 = 7

==SB	Store byte==

lui $4, 0x1234
ori $4, $0, 0x5678
lui $5, 0xBFC0
ori $5, $0, 0x001C
sb $4, 0($5)
lb $2, 0($5)
jr $0

3C041234
34045678
3C05BFC0
3405001C
A0A40000
80A20000
00000008

register_v0 = 0x00000078

==SH	Store half-word==

lui $4, 0x1234
ori $4, $0, 0x5678
lui $5, 0xBFC0
ori $5, $0, 0x001C
sh $4, 0($5)
lh $2, 0($5)
jr $0

3C041234
34045678
3C05BFC0
3405001C
A4A40000
84A40000
00000008

register_v0 = 0x00005678

==SLL	Shift left logical==

ori $4,$0,3
sll $2,$4,2
jr $0

34040003
00041080
00000008

register_v0 = 16

==SLLV	Shift left logical variable==

ori $4,$0,2
ori $5,$0,3
sllv $2,$5,$4
jr $0

34040002
34050003
00851004
00000008

register_v0 = 16

==SLT	Set on less than (signed)==

ORI $4 $zero 0xFFFF
ORI $5 $zero 0x000B
SLT $2 $4 $5
jr $0

3404FFFF
3405000B
0085102A
00000008

register_v0 = 0

==SLTI	Set on less than immediate (signed)==

ori $4, $0, 10
slti $2, $4, 9
jr $0

3404000a
28820009
00000008

register_v0 = 0

==SLTIU	Set on less than immediate unsigned==

ori $4, $0, 10
sltiu $2, $4, 9
jr $0

3404000a
2c820009
00000008

register_v0 = 0

==SLTU	Set on less than unsigned==

ori $4, $0, 10
ori $5, $0, 9
sltu $2, $4, $5
jr $0

3404000a
34050009
0085102b
00000008

register_v0 = 0

==SRA	Shift right arithmetic==

ori $4,$0,2
sra $2,$4,1
jr $0

34040001
00041043
00000008

register_v0 = 1

==SRAV	Shift right arithmetic==

ori $4,$0,2
ori $5 $0,1
srav $2,$5,$4
jr $0    

34040002
34050001
00851007
00000008

register_v0 = 1

==SRL	Shift right logical==

ori $4,$0,16
srl $2,$4,2
jr $0

34040010
00041082
00000008

register_v0 = 3

==SRLV	Shift right logical variable==

ori $4,$0,2
ori $5,$0,16
srlv $2,$5,$4
jr $0

34040002
34050010
00851006
00000008

register_v0 = 3

==SUBU	Subtract unsigned==

ori $4,$0,5
ori $5,$0,3
subu $2,$4,$5
jr $0

34040005
34050003
00851023
00000008

register_v0 = 2

==SW	Store word==

ori $4, $0, 0xFFFF  
ori $5, $0, 0x1008  
sw $4, 4($5)        
ori $5, $0, 0x100C   
lw $2, 0($5)       
jr $0               

3404FFFF
34051008
ACA40004
3405100C
8CA20000
00000008

register_v0 = 0x0000FFFF

==XOR	Bitwise exclusive or==

ori $4, $0, 5
ori $5, $0, 2
xor $2, $4, $5
jr $0

34040005
34050002
00851026
00000008

register_v0 = 7

==XORI	Bitwise exclusive or immediate==

ori $4,$0,5
xori $2,$4,0xF
jr $0

34040005
3882000F
00000008

register_v0 = 10
