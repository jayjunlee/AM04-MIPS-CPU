MIPS 32 bits

== Bits, Bytes, Hex ==
-- 8 bits = 1 byte = 2 hex
-- 32 bits = 4 bytes = 8 hex
-- e.g. 00000000 00000000 00000000 00000000 -> 0x00000000

== CPU ==
inputs: 
-- manual MIPS assembly code -> instructions in binaries
-- C code -> compiled c program under mips -> disassemble binaries -> assembly code -> instruction in binaries
-- these binary instructions goes into instruction memory
outputs:
-- output of the instructions
errors:
-- ?????? how do we detect errors ??????

== Submodules ==
-- ALU
-- Register File
-- Data Memory
-- Instruction Register
-- PC
-- Control Unit

== Testbench ==
-- ????? not so sure yet ?????

== Endianess ==
-- big endian: bytes are numbered starting with byte 0 at MSB
-- use -EB flag to ensure big endian

== Instruction Access ==
-- PC (program counter): 32 bit register
-- PC is initialised to 0xBFC00000
-- PC changed as instructions are executed
-- IR = Mem[PC] -> instruction is fetched from data memory using data at the address given by program counter

Address bus: CPU -> Memory
Data bus: CPU <=> Memory

== Register File ==
-- 32 general-purpose registers

== Program Counter ==
-- PC is just a 32 bit register in which the value (address of instruction) get updated by other blocks
-- Controlled by PCSrc (for branching or regular increment by 4 bytes)

== Questions ==
Pseudo-instructions -> how to deal with them -> convert to actual instructions?
Do we implement big-endian mips?
What verilator could be useful for
How would a testbench in c++ be helpful?
Don't understand that part where we need to implement cache

== Todo ==
Testbench in c++
Cache
CPU stall cycle

